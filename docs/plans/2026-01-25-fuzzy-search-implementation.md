# Fuzzy Search Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace basic text highlighting with fuzzy search featuring jump-to-match navigation, multiple match types (exact, contains, spelling, phonetic), inline badges, and filter toggles.

**Architecture:** All search logic lives in embedded JavaScript within the HTML template generated by `generate_html_template()` in `export.rs`. We'll add CSS for new UI elements, implement Metaphone and Levenshtein algorithms, build a search index on document decrypt, and replace the current `search()` function with a complete search system.

**Tech Stack:** Rust (template generation), vanilla JavaScript (search logic), CSS (styling)

---

### Task 1: Add CSS for New Search UI

**Files:**
- Modify: `src-tauri/src/export.rs:90-125` (CSS section)

**Step 1: Add new CSS styles**

Add these styles after the existing `.highlight` style (line 123):

```css
.search-controls {{ display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; margin-top: 0.5rem; }}
.search-nav {{ display: flex; align-items: center; gap: 0.5rem; }}
.search-nav button {{ padding: 4px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 1rem; }}
.search-nav button:hover:not(:disabled) {{ background: #f0f0f0; }}
.search-nav button:disabled {{ opacity: 0.5; cursor: not-allowed; }}
.search-counter {{ color: #666; font-size: 0.9rem; min-width: 100px; }}
.search-filters {{ display: flex; gap: 0.5rem; flex-wrap: wrap; }}
.search-filter {{ padding: 4px 8px; border: 1px solid #ddd; background: #f8f9fa; border-radius: 4px; font-size: 0.8rem; cursor: pointer; user-select: none; }}
.search-filter.active {{ background: #007bff; color: white; border-color: #007bff; }}
.search-filter.disabled {{ opacity: 0.5; cursor: not-allowed; }}
.match-badge {{ font-size: 0.7rem; color: #666; background: #e9ecef; padding: 1px 4px; border-radius: 3px; margin-left: 2px; vertical-align: middle; }}
.highlight {{ background: #ffeb3b; padding: 1px 0; }}
.highlight.current {{ background: #ff9800; outline: 2px solid #e65100; }}
```

**Step 2: Verify the edit**

Read the file and confirm CSS is properly inserted with correct Rust string escaping (double braces `{{` `}}`).

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "style: add CSS for fuzzy search UI components"
```

---

### Task 2: Add Levenshtein Distance Function

**Files:**
- Modify: `src-tauri/src/export.rs:545-598` (JavaScript section, before `search` function)

**Step 1: Add Levenshtein function**

Insert this function before the `search` function:

```javascript
function levenshtein(a, b) {{
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {{
        for (let j = 1; j <= a.length; j++) {{
            if (b.charAt(i-1) === a.charAt(j-1)) {{
                matrix[i][j] = matrix[i-1][j-1];
            }} else {{
                matrix[i][j] = Math.min(
                    matrix[i-1][j-1] + 1,
                    matrix[i][j-1] + 1,
                    matrix[i-1][j] + 1
                );
            }}
        }}
    }}
    return matrix[b.length][a.length];
}}
```

**Step 2: Verify the edit**

Read the file and confirm function is properly inserted.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add Levenshtein distance function for spelling matching"
```

---

### Task 3: Add Metaphone Algorithm

**Files:**
- Modify: `src-tauri/src/export.rs` (JavaScript section, after Levenshtein)

**Step 1: Add Metaphone function**

Insert after the Levenshtein function:

```javascript
function metaphone(word) {{
    if (!word || word.length < 2) return '';
    word = word.toUpperCase().replace(/[^A-Z]/g, '');
    if (!word) return '';

    // Initial letter rules
    const start = word.slice(0, 2);
    if (['KN', 'GN', 'PN', 'AE', 'WR'].includes(start)) word = word.slice(1);
    if (word[0] === 'X') word = 'S' + word.slice(1);
    if (start === 'WH') word = 'W' + word.slice(2);

    let result = '';
    let i = 0;
    const len = word.length;

    while (i < len && result.length < 6) {{
        const c = word[i];
        const next = word[i + 1] || '';
        const prev = word[i - 1] || '';

        if ('AEIOU'.includes(c)) {{
            if (i === 0) result += c;
        }} else if (c === 'B') {{
            if (!(i === len - 1 && prev === 'M')) result += 'B';
        }} else if (c === 'C') {{
            if (next === 'H') {{ result += 'X'; i++; }}
            else if ('IEY'.includes(next)) result += 'S';
            else result += 'K';
        }} else if (c === 'D') {{
            if (next === 'G' && 'IEY'.includes(word[i + 2] || '')) {{ result += 'J'; i++; }}
            else result += 'T';
        }} else if (c === 'G') {{
            if (next === 'H') {{ if (!'AEIOU'.includes(word[i + 2] || '')) i++; }}
            else if (next === 'N' && word[i + 2] === 'E' && word[i + 3] === 'D') {{}}
            else if ('IEY'.includes(next)) result += 'J';
            else result += 'K';
        }} else if (c === 'H') {{
            if ('AEIOU'.includes(next) && !'CSPTG'.includes(prev)) result += 'H';
        }} else if (c === 'K') {{
            if (prev !== 'C') result += 'K';
        }} else if (c === 'P') {{
            result += (next === 'H') ? (i++, 'F') : 'P';
        }} else if (c === 'Q') {{
            result += 'K';
        }} else if (c === 'S') {{
            if (next === 'H') {{ result += 'X'; i++; }}
            else if (next === 'I' && 'OA'.includes(word[i + 2] || '')) {{ result += 'X'; i++; }}
            else result += 'S';
        }} else if (c === 'T') {{
            if (next === 'H') {{ result += '0'; i++; }}
            else if (next === 'I' && 'OA'.includes(word[i + 2] || '')) {{ result += 'X'; i++; }}
            else result += 'T';
        }} else if (c === 'V') {{
            result += 'F';
        }} else if (c === 'W' || c === 'Y') {{
            if ('AEIOU'.includes(next)) result += c;
        }} else if (c === 'X') {{
            result += 'KS';
        }} else if (c === 'Z') {{
            result += 'S';
        }} else if ('FJLMNR'.includes(c)) {{
            result += c;
        }}
        i++;
    }}
    return result;
}}
```

**Step 2: Verify the edit**

Read the file and confirm function is properly inserted with correct brace escaping.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add Metaphone algorithm for phonetic matching"
```

---

### Task 4: Add Search Index Builder

**Files:**
- Modify: `src-tauri/src/export.rs` (JavaScript section, after Metaphone)

**Step 1: Add search index and state variables**

Insert after the Metaphone function:

```javascript
let searchIndex = [];
let searchState = {{
    term: '',
    matches: [],
    filters: {{ exact: true, contains: true, spelling: true, phonetic: true }},
    currentIndex: -1
}};

function buildSearchIndex() {{
    searchIndex = [];
    const content = document.getElementById('documentContent');
    const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, {{
        acceptNode: (node) => {{
            if (node.parentElement.closest('.toolbar')) return NodeFilter.FILTER_REJECT;
            return node.textContent.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }}
    }});

    let node;
    while (node = walker.nextNode()) {{
        const text = node.textContent;
        const words = text.match(/\b[\w']+\b/g) || [];
        words.forEach(word => {{
            if (word.length >= 2) {{
                searchIndex.push({{
                    text: word,
                    lowerText: word.toLowerCase(),
                    metaphone: metaphone(word),
                    node: node,
                    fullText: text
                }});
            }}
        }});
    }}
}}
```

**Step 2: Call buildSearchIndex after renderDocument**

Find the end of `renderDocument` function (around line 543) and add this call right before the closing brace:

```javascript
            buildSearchIndex();
```

**Step 3: Verify the edit**

Read the file to confirm both the function and the call are properly inserted.

**Step 4: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add search index builder for fuzzy matching"
```

---

### Task 5: Update Toolbar HTML with Search Controls

**Files:**
- Modify: `src-tauri/src/export.rs:243-246` (toolbar HTML in renderDocument)

**Step 1: Replace toolbar HTML**

Find the toolbar section (around line 243-246):
```javascript
            html += '<div class="toolbar">';
            html += '<input type="text" id="searchInput" class="search-input" placeholder="Search..." oninput="search(this.value)">';
            html += '<button class="print-btn" onclick="window.print()">Print</button>';
            html += '</div></div>';
```

Replace with:
```javascript
            html += '<div class="toolbar">';
            html += '<input type="text" id="searchInput" class="search-input" placeholder="Search..." oninput="debounceSearch(this.value)">';
            html += '<button class="print-btn" onclick="window.print()">Print</button>';
            html += '</div>';
            html += '<div class="search-controls" id="searchControls" style="display:none;">';
            html += '<div class="search-nav">';
            html += '<button onclick="prevMatch()" id="prevBtn" disabled>◀</button>';
            html += '<button onclick="nextMatch()" id="nextBtn" disabled>▶</button>';
            html += '<span class="search-counter" id="searchCounter"></span>';
            html += '</div>';
            html += '<div class="search-filters">';
            html += '<span class="search-filter active" data-type="exact" onclick="toggleFilter(this)">Exact (<span id="exactCount">0</span>)</span>';
            html += '<span class="search-filter active" data-type="contains" onclick="toggleFilter(this)">Contains (<span id="containsCount">0</span>)</span>';
            html += '<span class="search-filter active" data-type="spelling" onclick="toggleFilter(this)">Spelling (<span id="spellingCount">0</span>)</span>';
            html += '<span class="search-filter active" data-type="phonetic" onclick="toggleFilter(this)">Sounds-like (<span id="phoneticCount">0</span>)</span>';
            html += '</div>';
            html += '</div></div>';
```

**Step 2: Verify the edit**

Read the file to confirm the HTML is properly updated.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add search controls HTML with nav and filters"
```

---

### Task 6: Implement Core Search Function

**Files:**
- Modify: `src-tauri/src/export.rs` (replace existing search and highlightTextNodes functions)

**Step 1: Add debounce and new search function**

Replace the existing `search` and `highlightTextNodes` functions with:

```javascript
let searchTimeout;
function debounceSearch(term) {{
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => performSearch(term), 300);
}}

function performSearch(term) {{
    clearHighlights();
    searchState.term = term.toLowerCase();
    searchState.matches = [];
    searchState.currentIndex = -1;

    if (!term || term.length < 2) {{
        document.getElementById('searchControls').style.display = 'none';
        updateSearchUI();
        return;
    }}

    document.getElementById('searchControls').style.display = 'flex';
    const termMeta = metaphone(term);
    const matchMap = new Map(); // Deduplication: node+text -> match

    searchIndex.forEach(entry => {{
        const key = entry.node.textContent + '|' + entry.text;
        if (matchMap.has(key)) return; // Already matched at higher priority

        // Check match types in priority order
        const wordLower = entry.lowerText;
        const termLower = term.toLowerCase();

        // Exact (whole word, case-insensitive)
        if (wordLower === termLower) {{
            matchMap.set(key, {{ ...entry, type: 'exact' }});
            return;
        }}

        // Contains (substring)
        if (term.length >= 3 && wordLower.includes(termLower)) {{
            matchMap.set(key, {{ ...entry, type: 'contains' }});
            return;
        }}

        // Spelling (Levenshtein)
        const maxDist = term.length >= 8 ? 3 : 2;
        const dist = levenshtein(wordLower, termLower);
        if (dist > 0 && dist <= maxDist) {{
            matchMap.set(key, {{ ...entry, type: 'spelling', distance: dist }});
            return;
        }}

        // Phonetic (Metaphone)
        if (term.length >= 3 && termMeta && entry.metaphone === termMeta) {{
            matchMap.set(key, {{ ...entry, type: 'phonetic' }});
        }}
    }});

    // Sort: by type priority, then document order
    const typeOrder = {{ exact: 0, contains: 1, spelling: 2, phonetic: 3 }};
    searchState.matches = Array.from(matchMap.values())
        .sort((a, b) => typeOrder[a.type] - typeOrder[b.type]);

    highlightMatches();
    updateSearchUI();

    if (getVisibleMatches().length > 0) {{
        searchState.currentIndex = 0;
        scrollToCurrentMatch();
    }}
}}
```

**Step 2: Verify the edit**

Read the file to confirm functions are properly inserted.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: implement fuzzy search with multiple match types"
```

---

### Task 7: Implement Highlighting Functions

**Files:**
- Modify: `src-tauri/src/export.rs` (JavaScript section, after performSearch)

**Step 1: Add highlight functions**

Insert after `performSearch`:

```javascript
function clearHighlights() {{
    document.querySelectorAll('mark.highlight').forEach(mark => {{
        const parent = mark.parentNode;
        const badge = mark.nextSibling;
        if (badge && badge.classList && badge.classList.contains('match-badge')) {{
            badge.remove();
        }}
        parent.replaceChild(document.createTextNode(mark.textContent), mark);
        parent.normalize();
    }});
}}

function highlightMatches() {{
    const visible = getVisibleMatches();
    const termLower = searchState.term.toLowerCase();

    visible.forEach((match, idx) => {{
        const node = match.node;
        const text = node.textContent;
        const regex = new RegExp('(' + match.text.replace(/[.*+?^${{}}()|[\]\\]/g, '\\$&') + ')', 'gi');

        if (!regex.test(text)) return;
        regex.lastIndex = 0;

        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let m;

        while ((m = regex.exec(text)) !== null) {{
            if (m.index > lastIndex) {{
                fragment.appendChild(document.createTextNode(text.slice(lastIndex, m.index)));
            }}

            const mark = document.createElement('mark');
            mark.className = 'highlight';
            mark.dataset.matchIndex = idx;
            mark.dataset.matchType = match.type;
            mark.textContent = m[0];
            fragment.appendChild(mark);

            const badge = document.createElement('span');
            badge.className = 'match-badge';
            badge.textContent = match.type === 'spelling' ? '~spelling' :
                               match.type === 'phonetic' ? 'sounds like' : match.type;
            fragment.appendChild(badge);

            lastIndex = regex.lastIndex;
            break; // Only highlight first occurrence per word
        }}

        if (lastIndex < text.length) {{
            fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
        }}

        if (lastIndex > 0) {{
            node.parentNode.replaceChild(fragment, node);
        }}
    }});
}}

function getVisibleMatches() {{
    return searchState.matches.filter(m => searchState.filters[m.type]);
}}
```

**Step 2: Verify the edit**

Read the file to confirm functions are properly inserted.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add highlight and visibility functions"
```

---

### Task 8: Implement Navigation Functions

**Files:**
- Modify: `src-tauri/src/export.rs` (JavaScript section, after highlighting functions)

**Step 1: Add navigation functions**

Insert after the highlighting functions:

```javascript
function updateSearchUI() {{
    const counts = {{ exact: 0, contains: 0, spelling: 0, phonetic: 0 }};
    searchState.matches.forEach(m => counts[m.type]++);

    document.getElementById('exactCount').textContent = counts.exact;
    document.getElementById('containsCount').textContent = counts.contains;
    document.getElementById('spellingCount').textContent = counts.spelling;
    document.getElementById('phoneticCount').textContent = counts.phonetic;

    // Update filter states
    ['exact', 'contains', 'spelling', 'phonetic'].forEach(type => {{
        const el = document.querySelector(`.search-filter[data-type="${{type}}"]`);
        if (counts[type] === 0) {{
            el.classList.add('disabled');
            el.classList.remove('active');
            searchState.filters[type] = false;
        }} else {{
            el.classList.remove('disabled');
        }}
    }});

    const visible = getVisibleMatches();
    const counter = document.getElementById('searchCounter');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    if (visible.length === 0) {{
        counter.textContent = 'No matches';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
    }} else {{
        const current = searchState.currentIndex + 1;
        counter.textContent = `Match ${{current}} of ${{visible.length}}`;
        prevBtn.disabled = visible.length <= 1;
        nextBtn.disabled = visible.length <= 1;
    }}

    updateCurrentHighlight();
}}

function updateCurrentHighlight() {{
    document.querySelectorAll('mark.highlight.current').forEach(el => el.classList.remove('current'));
    const visible = getVisibleMatches();
    if (searchState.currentIndex >= 0 && searchState.currentIndex < visible.length) {{
        const mark = document.querySelector(`mark.highlight[data-match-index="${{searchState.currentIndex}}"]`);
        if (mark) mark.classList.add('current');
    }}
}}

function scrollToCurrentMatch() {{
    updateCurrentHighlight();
    const mark = document.querySelector('mark.highlight.current');
    if (mark) {{
        mark.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
    }}
    updateSearchUI();
}}

function nextMatch() {{
    const visible = getVisibleMatches();
    if (visible.length === 0) return;
    searchState.currentIndex = (searchState.currentIndex + 1) % visible.length;
    scrollToCurrentMatch();
}}

function prevMatch() {{
    const visible = getVisibleMatches();
    if (visible.length === 0) return;
    searchState.currentIndex = (searchState.currentIndex - 1 + visible.length) % visible.length;
    scrollToCurrentMatch();
}}

function toggleFilter(el) {{
    const type = el.dataset.type;
    const counts = {{ exact: 0, contains: 0, spelling: 0, phonetic: 0 }};
    searchState.matches.forEach(m => counts[m.type]++);

    if (counts[type] === 0) return; // Can't toggle empty filters

    searchState.filters[type] = !searchState.filters[type];
    el.classList.toggle('active', searchState.filters[type]);

    clearHighlights();
    highlightMatches();

    const visible = getVisibleMatches();
    if (visible.length > 0) {{
        searchState.currentIndex = Math.min(searchState.currentIndex, visible.length - 1);
        if (searchState.currentIndex < 0) searchState.currentIndex = 0;
    }} else {{
        searchState.currentIndex = -1;
    }}

    updateSearchUI();
    if (searchState.currentIndex >= 0) scrollToCurrentMatch();
}}
```

**Step 2: Verify the edit**

Read the file to confirm all navigation functions are properly inserted.

**Step 3: Commit**

```bash
git add src-tauri/src/export.rs
git commit -m "feat: add search navigation and filter toggle functions"
```

---

### Task 9: Build and Test

**Files:**
- None (verification only)

**Step 1: Build the frontend**

```bash
cd /workspace/honey-did && npm run build
```

Expected: Build succeeds

**Step 2: Build the Rust backend (if network available)**

```bash
cd /workspace/honey-did/src-tauri && cargo build
```

Expected: Build succeeds (or skip if network unavailable)

**Step 3: Manual test plan**

To test the search functionality:
1. Run the app and create some test data (e.g., bank account "Ally Bank", contact "Sally Smith")
2. Export to HTML with a passphrase
3. Open the exported HTML in a browser
4. Enter passphrase to decrypt
5. Test searches:
   - "ally" → should show Ally as exact, Sally as contains
   - "aly" → should show Ally as spelling match
   - "smyth" → should show Smith as sounds-like match
6. Test navigation with ◀ ▶ buttons
7. Test filter toggles
8. Verify badge labels appear correctly

**Step 4: Final commit**

```bash
git add -A
git commit -m "feat: complete fuzzy search with jump-to-match navigation

- Exact, contains, spelling (Levenshtein), phonetic (Metaphone) matching
- Inline badges showing match type
- Filter toggles to show/hide match types
- Prev/next navigation with match counter
- Debounced search input (300ms)
- Pre-built search index for performance"
```

---

## Summary

| Task | Description | Estimated Complexity |
|------|-------------|---------------------|
| 1 | CSS for search UI | Simple |
| 2 | Levenshtein function | Simple |
| 3 | Metaphone algorithm | Medium |
| 4 | Search index builder | Medium |
| 5 | Toolbar HTML update | Simple |
| 6 | Core search function | Medium |
| 7 | Highlighting functions | Medium |
| 8 | Navigation functions | Medium |
| 9 | Build and test | Simple |

Total: 9 tasks
